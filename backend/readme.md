    #JPA
 ## @GeneratedValue(strategy = GenerationType.IDENTITY)
 
 “Without @GeneratedValue, JPA expects the ID to be set manually.
If we forget or multiple inserts happen concurrently, it causes constraint violations and duplicate key issues. Using IDENTITY delegates safe ID generation to the database.”
## why spring  
## spring security !
In my application, authentication is completely stateless and based on JWTs rather than sessions or cookies. A user first registers by sending their credentials to an open /auth/register endpoint, where the password is securely hashed and stored in the database. When the user logs in via /auth/login, Spring Security uses the AuthenticationManager, UserDetailsService, and PasswordEncoder to verify the username and password. If the credentials are valid, the backend generates a JWT containing the username, an issue time, an expiration time, and a cryptographic signature, and sends that token back to the client. From that point on, the JWT becomes the user’s identity. Every protected request must include the token in the Authorization header using the Bearer scheme. For each incoming request, the JwtFilter runs before Spring’s built-in authentication filters, extracts the token, validates its signature and expiration, loads the corresponding user from the database, and then places an authenticated object into Spring Security’s context. Once the security context is populated, Spring considers the request authenticated and allows it to reach the controller. If the token is missing, invalid, expired, or malformed, the request is rejected before any business logic runs. This flow ensures that authentication is enforced consistently on every request, without server-side sessions, while keeping your controllers clean and focused on application logic.
